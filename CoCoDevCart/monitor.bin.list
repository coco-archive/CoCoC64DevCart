Defines:
CPU = 6809

Address defines:
FF40 = _DEV_PIA_0
FF44 = _DEV_PIA_1
FF00 = _PIA_0
FF20 = _PIA_1
FF40 = _PIA_CART
A000 = _ROM_BASIC
A006 = _ROM_BLKIN
A008 = _ROM_BLKOUT
C000 = _ROM_CART
A002 = _ROM_CHROUT
A004 = _ROM_CSRDON
8000 = _ROM_EXTENDED
A00A = _ROM_JOYIN
A000 = _ROM_POLCAT
FFDE = _SAM_ALL_RAM
FFD6 = _SAM_CPU_RATE
FFC6 = _SAM_DISPLAY_OFFSET
FFDA = _SAM_MEMORY_SIZE
FFD4 = _SAM_PAGE_NUMBER
FFC0 = _SAM_VIDEO_MODE
FFF6 = _VECTOR_FIRQ
FFF8 = _VECTOR_IRQ
FFFC = _VECTOR_NMI
FFF0 = _VECTOR_NOT_USED
FFFE = _VECTOR_RESET
FFFA = _VECTOR_SW1
FFF4 = _VECTOR_SWI2
FFF2 = _VECTOR_SWI3

Code labels:
E02C = ALLRAM
E045 = ALLRAME
E033 = AR_1
E00C = Copy1
E021 = DAR1
E017 = DOALLR
E072 = DO_ABORT
E0A4 = DO_EXECUTE
E08D = DO_LOAD
E076 = DO_UPLOAD
E045 = MONITOR
E0BC = load
E054 = main
E0C5 = readByte
E0B3 = upload
E0C5 = wait1
E0D9 = wait2
E102 = wait3
E112 = wait4
E122 = wait5
E132 = wait6
E0F3 = writeByte

; build tools.assembler.Assembler monitor.asm monitor.bin -list
; build tools.coco.DevCartLoader monitor.bin 0x7000
; build pause 4000
;@build tools.coco.DevCartLoader L ..\roms\daggorath.bin 0xC000 E 0xC000

; TODO:Assembler better error message if I leave the ":" off the origin "0x7000"

; TODO:Communication need a throttle mechanism for large files sent over COM6 with no flow. Right now we
;   rely on long delays

define CPU = 6809

include coco_hardware.asm
; 6833 SAM Mapped into Color Computer memory at $FFC0
; There are no data lines to the SAM. Bits are set by
; writing to odd addresses and cleared by writing to
; even addresses. The LSB of each of several fields 
; appears first in memory as follows:

; V0 V1 V2    F0 F1 F2 F3 F4 F5 F6    P0    R0 R1    M0 M1    TY

address _SAM_VIDEO_MODE=0xFFC0
;
; Video Mode (v0-V2)
; 000 AI, AE, S4, S6
; 001 G1C, G1R
; 010 G2C
; 011 G2R
; 100 G3C
; 101 G3R
; 110 G6R, G6C
; 111 Not Used

address _SAM_DISPLAY_OFFSET=0xFFC6
;
; VDG Display Offset (F0-F6)
; Upper 7 bits of offset means these are in 512 byte pages ...
; 0000001 = 00000010 00000000 -> 512
; BASIC ROM initializes to 0x0400 at startup

address _SAM_PAGE_NUMBER=0xFFD4
;
; Page Number (P1)
; Allows for two pages in lower 32K address ... not used

address _SAM_CPU_RATE=0xFFD6
;
; CPU Rate (R0-R1)
; 00 0.89 MHz
; 01 0.89 MHz, 1.79 MHz
; 10 Not Used
; 11 Not Used

address _SAM_MEMORY_SIZE=0xFFDA
; Memory size (M0-M1)
; 00  4K
; 01 16K
; 10 32/64K
; 11 Not used

address _SAM_ALL_RAM=0xFFDE
; Map type (TY)
; 0 for normal mode (32K RAM, upper half ROM)
; 1 for all-RAM (64K RAM, no ROM)

; Input/Output Devices
address _PIA_0   =  0xFF00
address _PIA_1   =  0xFF20
address _PIA_CART=  0xFF40

; 6809 Vectors
address _VECTOR_RESET    =  0xFFFE
address _VECTOR_NMI      =  0xFFFC
address _VECTOR_SW1      =  0xFFFA
address _VECTOR_IRQ      =  0xFFF8
address _VECTOR_FIRQ     =  0xFFF6
address _VECTOR_SWI2     =  0xFFF4
address _VECTOR_SWI3     =  0xFFF2
address _VECTOR_NOT_USED =  0xFFF0

; ROM Areas
address _ROM_EXTENDED =  0x8000
address _ROM_BASIC    =  0xA000
address _ROM_CART     =  0xC000

; OS Service Vectors in ROM
address _ROM_POLCAT =  0xA000 ; Polls keyboard for a character
address _ROM_CHROUT =  0xA002 ; Outputs a character to screen or device
address _ROM_CSRDON =  0xA004 ; Starts cassette and prepares for reading
address _ROM_BLKIN  =  0xA006 ; Reads a block from cassette
address _ROM_BLKOUT =  0xA008 ; Writes a block to cassette
address _ROM_JOYIN  =  0xA00A ; Reads joystick values

; Text mode uses the following character set:
; 0-64     reversed characters
; 64-128   normal characters
; 128-255  graphics patterns
; @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\] UP-ARROW LEFT-ARROW SPACE !"#$%&'()*+,-./0123456789:;<=>?

;ASCIITRANS:
;        fcb     32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
;        fcb       32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
;        fcb     96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111
;        fcb       112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
;        fcb     64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
;        fcb       80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
;        fcb     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
;        fcb       16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 

address _DEV_PIA_0 = 0xFF40
address _DEV_PIA_1 = 0xFF44

; The monitor program is copied to E000-EFFF (All-RAM mode) and execute.
; The code up to the line of ========== is guaranteed relocatable allowing the
; coping code to run in ROM and JMP to RAM.
;
0xE000:       

E000: 8D 15      BSR     DOALLR          ; Copy ROM to ALL-RAM mode

E002: 8E C0 00   LDX     #0xC000         ; Cartridge memory
E005: CE E0 00   LDU     #0xE000         ; RAM area
E008: 10 8E 10 00 LDY     #0x1000         ; 4K
E00C: A6 80      Copy1:  LDA     ,X+             ; Copy ...
E00E: A7 C0      STA     ,U+             ; ... monitor ...
E010: 31 3F      LEAY    -1,Y            ; ... to ...
E012: 26 F8      BNE     Copy1           ; ... RAM

E014: 7E E0 45   JMP     MONITOR         ; Start the monitor in RAM (JMP ... *NOT* BRA)

; ================================================================================
; Utility functions

; This routine copies the ALLRAM routine to memory and executes it there.
; This routine can't run in ROM since ROM gets switched out momentarily
; during the copy.
;
E017: 8E E0 2C   DOALLR: LDX     #ALLRAM          ; Start of ALLRAM function
E01A: CE 7F 00   LDU     #0x7F00          ; Destination in upper RAM
E01D: 10 8E 00 19 LDY     #ALLRAME-ALLRAM  ; Number of bytes to copy
E021: A6 80      DAR1:   LDA     ,X+              ; Copy the ...
E023: A7 C0      STA     ,U+              ; ... routine ...
E025: 31 3F      LEAY    -1,Y             ; ... to ...
E027: 26 F8      BNE     DAR1             ; ... RAM
E029: 7E 7F 00   JMP     0x7F00           ; Execute routine (return to our caller)
;
; This routine copies the contents of ROM into the upper 32 bytes
; of all-ram mode.
;
E02C: 34 01      ALLRAM: PSHS    CC             ; Save interrupt status
E02E: 1A 50      ORCC    #0x50          ; Turn off interrupts
E030: 8E 80 00   LDX     #0x8000        ; Start of ROM
E033: B7 FF DE   AR_1:   STA     _SAM_ALL_RAM   ; Switch ROM bank ON
E036: A6 84      LDA     ,X             ; Get value from ROM
E038: B7 FF DF   STA     _SAM_ALL_RAM+1 ; Switch ROM bank OFF
E03B: A7 80      STA     ,X+            ; Store value to RAM under ROM bank
E03D: 8C FF 00   CMPX    #0xFF00        ; Reached the end of ROM?
E040: 26 F1      BNE     AR_1           ; No ... go back for more
E042: 35 01      PULS    CC             ; Restore interrupts
E044: 39         RTS
ALLRAME:

;===========================================================================

MONITOR:        

E045: 86 00      LDA	#0		; Select the ...
E047: B7 FF 47   STA	0xFF47		; ... data-direction register port B
E04A: 86 0E      LDA     #0b_0000_11_10  ; Inputs and outputs
E04C: B7 FF 46   STA	0xFF46		; Directions of pins on port B
E04F: 86 04      LDA	#4		; Select the ...
E051: B7 FF 47   STA	0xFF47		; ... data register port B

E054: 86 4D      main:   LDA     #77             ; M for "MONITOR"
E056: B7 04 02   STA     0x402           ; Tell the user where we are
E059: 8D 6A      BSR     readByte        ; Get the command
E05B: 81 4C      CMPA    #76             ; 'L' for LOAD
E05D: 27 2E      BEQ     DO_LOAD         ; Do load routine
E05F: 81 45      CMPA    #69             ; 'E' for EXECUTE
E061: 27 41      BEQ     DO_EXECUTE      ; Do execute routine
E063: 81 41      CMPA    #65             ; 'A' for ABORT
E065: 27 0B      BEQ     DO_ABORT        ; Do abort
E067: 81 55      CMPA    #85             ; 'U' for UPLOAD
E069: 27 0B      BEQ     DO_UPLOAD       ; Do upload
E06B: 86 3F      LDA     #63             ; '?'
E06D: B7 04 03   STA     0x403           ; Show that an error occurred
E070: 20 E2      BRA     main            ; Back to the top to wait

DO_ABORT:
E072: B7 04 02   STA     0x402           ; Show the command
E075: 39         RTS                     ; Only works when executed from BASIC

DO_UPLOAD:
E076: B7 04 02   STA     0x402
E079: 8D 4A      BSR 	readByte	; Read the source LSB
E07B: 1F 89      TFR 	A,B		; Hold it
E07D: 8D 46      BSR	readByte	; Read the source MSB
E07F: 1F 01      TFR	D,X		; Source to X

E081: 8D 42      BSR	readByte	; Read the count LSB
E083: 1F 89      TFR	A,B		; Hold it
E085: 8D 3E      BSR	readByte	; Read the count MSB
E087: 1F 02      TFR	D,Y		; Count to Y

E089: 8D 28      BSR     upload          ; Call the upload routine
E08B: 20 C7      BRA     main            ; Back to main

DO_LOAD:
E08D: B7 04 02   STA     0x402           ; Show the command
E090: 8D 33      BSR 	readByte	; Read the destination LSB
E092: 1F 89      TFR 	A,B		; Hold it
E094: 8D 2F      BSR	readByte	; Read the destination MSB
E096: 1F 01      TFR	D,X		; Destination to X

E098: 8D 2B      BSR	readByte	; Read the count LSB
E09A: 1F 89      TFR	A,B		; Hold it
E09C: 8D 27      BSR	readByte	; Read the count MSB
E09E: 1F 02      TFR	D,Y		; Count to Y

E0A0: 8D 1A      BSR     load            ; Do the load

E0A2: 20 B0      BRA     main            ; Back to monitor

DO_EXECUTE:
E0A4: B7 04 02   STA     0x402           ; Show the command
E0A7: 8D 1C      BSR 	readByte	; Read the destination LSB
E0A9: 1F 89      TFR 	A,B		; Hold it
E0AB: 8D 18      BSR	readByte	; Read the destination MSB
E0AD: 1F 03      TFR     D,U             ; Destination to U
E0AF: AD C4      JSR     ,U              ; Jump to the code (return here)
E0B1: 20 A1      BRA     main            ; Back to monitor

; ================================================================================
; I/O functions

E0B3: A6 80      upload: LDA     ,X+             ; Get the next byte
E0B5: 8D 3C      BSR     writeByte       ; Send it to the host
E0B7: 31 3F      LEAY    -1,Y            ; All sent?
E0B9: 26 F8      BNE     upload          ; No ... do all
E0BB: 39         RTS                     ; Done

E0BC: 8D 07      load:   BSR     readByte	; Get the next byte
E0BE: A7 80      STA     ,X+		; Store it to memory
E0C0: 31 3F      LEAY    -1,Y		; All done?
E0C2: 26 F8      BNE     load    	; No ... do all
E0C4: 39         RTS                     ; Done

; Read a byte from the Port B. The upper 4 bits of B are the 
; data with the most-significant-nibble coming first followed
; by the least significant. The lower bit is the data clock.
; The MSN is read on 0->1 transition. The LSN is read on 1->0.
; Bit 1 is an ACK bit from the coco back to the propeller. It
; Toggles with each nibble read.
;
readByte:

; Read Upper 4 bits of data
E0C5: B6 FF 46   wait1:  LDA	0xFF46		; Get port B data
E0C8: 84 01      ANDA	#1		; Lower bit a 0?
E0CA: 27 F9      BEQ	wait1		; Yes ... wait for the clock

E0CC: B6 FF 46   LDA	0xFF46		; Get port B data
E0CF: 84 F0      ANDA	#0xF0		; Only need the upper 4 bits
E0D1: B7 04 00   STA     0x0400          ; To screen for progress

E0D4: 86 02      LDA     #2              ; Set ACK ...
E0D6: B7 FF 46   STA     0xFF46          ; ... to 1

E0D9: B6 FF 46   wait2:	LDA	0xFF46		; Get port B data
E0DC: 84 01      ANDA	#1		; Lower bit a 0?
E0DE: 26 F9      BNE	wait2		; No ... wait for the clock

E0E0: B6 FF 46   LDA	0xFF46		; Get port B data
E0E3: 44         LSRA			; Shift ...
E0E4: 44         LSRA			; ... the ...
E0E5: 44         LSRA			; ... LSN ...
E0E6: 44         LSRA			; ... into place
E0E7: 84 0F      ANDA	#0x0F		; Keep only the lower 4 bits
E0E9: B7 04 01   STA     0x0401          ; To screen for progress
E0EC: BA 04 00   ORA	0x0400		; Combine nibbles

E0EF: 7F FF 46   CLR     0xFF46          ; Clear ACK

E0F2: 39         RTS			; Return value in A


writeByte:

E0F3: 34 06      PSHS    A,B             ; Preserve the registers
E0F5: 1F 89      TFR     A,B             ; Original value to B
        
E0F7: 47         ASRA                    ; xx00yy00
E0F8: 47         ASRA                    ; ...
E0F9: 47         ASRA                    ; ...
E0FA: 47         ASRA                    ; ...
E0FB: 84 0C      ANDA    #0b00001100     ; ...
E0FD: 8A 02      ORA     #2              ; Toggle clock 0 to 1
E0FF: B7 FF 46   STA     0xFF46          ; Send 2 bits to host

E102: B6 FF 46   wait3:  LDA     0xFF46          ; Wait for ...
E105: 84 01      ANDA    #1              ; ... ACK to ...
E107: 27 F9      BEQ     wait3           ; ... toggle from 0 to 1

E109: 1F 98      TFR     B,A             ; Original value
E10B: 47         ASRA                    ; 00xxyy00
E10C: 47         ASRA                    ; ...
E10D: 84 0C      ANDA    #0b00001100     ; ...
E10F: B7 FF 46   STA     0xFF46          ; Send 2 bits to host (clock 1 to 0)

E112: B6 FF 46   wait4:  LDA     0xFF46          ; Wait for ...
E115: 84 01      ANDA    #1              ; ... ACK to ...
E117: 26 F9      BNE     wait4           ; ... toggle from 1 to 0

E119: 1F 98      TFR     B,A             ; 0000**00
E11B: 84 0C      ANDA    #0b00001100     ; ...
E11D: 8A 02      ORA     #2              ; Toggle clock from 0 to 1
E11F: B7 FF 46   STA     0xFF46          ; Send 2 bits to host
 
E122: B6 FF 46   wait5:  LDA     0xFF46          ; Wait for ...
E125: 84 01      ANDA    #1              ; ... ACK to ...
E127: 27 F9      BEQ     wait5           ; ... toggle from 0 to 1

E129: 1F 98      TFR     B,A             ; Original value
E12B: 48         ASLA                    ; 0000yyxx
E12C: 48         ASLA                    ; ...
E12D: 84 0C      ANDA    #0b00001100     ; ...
E12F: B7 FF 46   STA     0xFF46          ; Send 2 bits to host (clock 1 to 0)

E132: B6 FF 46   wait6:  LDA     0xFF46          ; Wait for ...
E135: 84 01      ANDA    #1              ; ... ACK to ...
E137: 26 F9      BNE     wait6           ; ... toggle from 1 to 0

E139: 35 86      PULS    A,B,PC          ; Restore and out

